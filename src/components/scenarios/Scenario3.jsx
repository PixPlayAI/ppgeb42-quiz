import React, { useEffect, useRef, useCallback } from 'react';
import PropTypes from 'prop-types';
import { generateScenarioContent } from '../../services/openai';

// ConfiguraÃ§Ã£o inicial sempre com "Carregando..."
let SCENARIO_CONFIG = {
  id: 'scenario3',
  title: 'CenÃ¡rio II: AtenuaÃ§Ã£o de RadiaÃ§Ã£o 2D',
  question: 'Carregando...',
  options: [
    {
      id: 'option1',
      text: 'Carregando...',
      isCorrect: true,
    },
    {
      id: 'option2',
      text: 'Carregando...',
      isCorrect: false,
    },
    {
      id: 'option3',
      text: 'Carregando...',
      isCorrect: false,
    },
    {
      id: 'option4',
      text: 'Carregando...',
      isCorrect: false,
    },
  ],
  successMessage: 'Carregando...',
  detailedExplanation: 'Carregando...',
};

// VariÃ¡vel para controlar a inicializaÃ§Ã£o
let isInitialized = false;

// FunÃ§Ã£o para resetar a configuraÃ§Ã£o
const resetConfig = () => {
  SCENARIO_CONFIG = {
    id: 'scenario3',
    title: 'CenÃ¡rio II: AtenuaÃ§Ã£o de RadiaÃ§Ã£o 2D',
    question: 'Carregando...',
    options: [
      {
        id: 'option1',
        text: 'Carregando...',
        isCorrect: true,
      },
      {
        id: 'option2',
        text: 'Carregando...',
        isCorrect: false,
      },
      {
        id: 'option3',
        text: 'Carregando...',
        isCorrect: false,
      },
      {
        id: 'option4',
        text: 'Carregando...',
        isCorrect: false,
      },
    ],
    successMessage: 'Carregando...',
    detailedExplanation: 'Carregando...',
  };
};

const SIMULATION_CONFIG = {
  startPoint: { x: 50, y: 150 },
  barrier: {
    x: 190,
    y: 75,
    width: 20,
    height: 150,
  },
};

const scenarioPrompt = `Gere uma questÃ£o de mÃºltipla escolha sobre o seguinte cenÃ¡rio:
Nesta simulaÃ§Ã£o 2D, sÃ£o mostrados dois cenÃ¡rios de atenuaÃ§Ã£o de radiaÃ§Ã£o:
- No primeiro cenÃ¡rio hÃ¡ uma emissÃ£o intensa com muitas partÃ­culas a partir da fonte, bem mais radioativa.
- No segundo cenÃ¡rio hÃ¡ uma emissÃ£o bem menor e e espaÃ§ada da fonte, bem menos radioativa.
- Em ambos os casos as partÃ­culas podem ser refletidas, transmitidas ou absorvidas pela barreira

A questÃ£o deve avaliar se o aluno compreende as aplicaÃ§Ãµes prÃ¡ticas dessas diferentes intensidades de radiaÃ§Ã£o, por exemplo uma baixa radiaÃ§Ã£o pode ser aplicÃ¡vel a um exame diagnÃ³stico (ex.: cintilografia) jÃ¡ alta radiaÃ§Ã£o pode ser aplicÃ¡vel a um Tratamento ( ex.: radioterapia). IMPORTANTE: Os textos devem ser curtos pois o candidato terÃ¡ aproximadamente 20 segundos para ver o cenÃ¡rio ler tudo e marcar a resposta correta.

Requisitos:
- A questÃ£o deve ter 4 alternativas
- Apenas uma alternativa deve estar correta
- As alternativas incorretas devem ser plausÃ­veis mas claramente distinguÃ­veis e uma alternativa deve ser absurda e totalmente nada a ver irÃ´nica ou engraÃ§ada.
- Foque em aplicaÃ§Ãµes prÃ¡ticas e na escolha adequada de diferentes radioisÃ³topos
- Inclua uma mensagem de parabÃ©ns que reforce o conceito especÃ­fico que o aluno demonstrou dominar
- Inclua uma explicaÃ§Ã£o detalhada da resposta correta e porque as outras alternativas estÃ£o erradas
- Os textos devem ser curtos pois o candidato terÃ¡ aproximadamente 20 segundos para ver o cenÃ¡rio ler tudo e marcar a resposta correta.


Retorne a resposta EXATAMENTE neste formato JSON:
{
  "id": "scenario3",
  "title": "CenÃ¡rio II: AtenuaÃ§Ã£o de RadiaÃ§Ã£o 2D",
  "question": "[Sua pergunta aqui]",
  "options": [
    {
      "id": "option1",
      "text": "[Texto da primeira alternativa]",
      "isCorrect": true
    },
    {
      "id": "option2",
      "text": "[Texto da segunda alternativa]",
      "isCorrect": false
    },
    {
      "id": "option3",
      "text": "[Texto da terceira alternativa]",
      "isCorrect": false
    },
    {
      "id": "option4",
      "text": "[Texto da quarta alternativa]",
      "isCorrect": false
    }
  ],
  "successMessage": "[Mensagem de parabÃ©ns explicando porque a resposta estÃ¡ correta e reforÃ§ando o conceito que o aluno dominou], nÃ£o cite alternativa a, b, c, d ou 1, 2, 3, 4 pois elas sÃ£o embaralhadas",
  "detailedExplanation": "[ExplicaÃ§Ã£o detalhada da resposta correta e anÃ¡lise de por que cada uma das outras alternativas estÃ¡ incorreta], nÃ£o cite alternativa a, b, c, d ou 1, 2, 3, 4 pois elas sÃ£o embaralhadas"
}`;
const getSimulationConfig = (scenarioNumber) => {
  return {
    particleInterval: scenarioNumber === 1 ? 5 : 50,
    maxParticles: scenarioNumber === 1 ? 400 : 40,
    ricochetProbability: 0.8,
    transmissionProbability: 0.15,
  };
};
const Scenario3 = ({ isPlaying, isDark, scenarioNumber = 1 }) => {
  const canvasRef = useRef(null);
  const particlesRef = useRef([]);
  const animationFrameRef = useRef(null);
  const lastParticleTimeRef = useRef(0);

  // FunÃ§Ã£o para atualizar a configuraÃ§Ã£o e disparar evento
  const updateConfig = useCallback((newConfig) => {
    SCENARIO_CONFIG = newConfig;
    window.dispatchEvent(new CustomEvent('scenarioConfigUpdated'));
  }, []);

  useEffect(() => {
    const fetchScenarioContent = async () => {
      // Se jÃ¡ foi inicializado, nÃ£o faz nada
      if (isInitialized) return;

      try {
        isInitialized = true; // Marca como inicializado antes da chamada
        const generatedContent = await generateScenarioContent(scenarioPrompt);

        // Verifica se o conteÃºdo foi gerado corretamente
        if (!generatedContent.successMessage || !generatedContent.detailedExplanation) {
          generatedContent.successMessage =
            'ParabÃ©ns! VocÃª demonstrou compreender como diferentes intensidades de radiaÃ§Ã£o podem ser aplicadas em contextos especÃ­ficos, considerando tanto aspectos de seguranÃ§a quanto eficÃ¡cia terapÃªutica.';
          generatedContent.detailedExplanation =
            'A resposta correta considera que diferentes intensidades de radiaÃ§Ã£o sÃ£o adequadas para diferentes aplicaÃ§Ãµes e que a escolha do radioisÃ³topo deve levar em conta nÃ£o apenas a intensidade, mas tambÃ©m o tipo de radiaÃ§Ã£o emitida. ' +
            'AlÃ©m disso, a atenuaÃ§Ã£o da radiaÃ§Ã£o Ã© um fator essencial tanto para a seguranÃ§a quanto para a eficÃ¡cia das aplicaÃ§Ãµes. ' +
            'As outras respostas estÃ£o incorretas porque confundem as aplicaÃ§Ãµes apropriadas para cada intensidade de radiaÃ§Ã£o, apresentam interpretaÃ§Ãµes equivocadas sobre atenuaÃ§Ã£o e blindagem, ou estabelecem associaÃ§Ãµes inadequadas entre radioisÃ³topos e suas possÃ­veis aplicaÃ§Ãµes.NÃ£o cite o nÃºmero da alternativa como por exemplo primeira, segunda, terceria, quarta ou A, B, C, D ou 1, 2, 3, 4 pois as alternativas estÃ£o embaralhadas';
        }

        // Atualiza a configuraÃ§Ã£o
        SCENARIO_CONFIG = {
          ...generatedContent,
          id: 'scenario3',
          title: 'MonteCarloQuiz.online PPGEB42 turma 2024/02',
        };

        // Dispara o evento de atualizaÃ§Ã£o
        updateConfig(SCENARIO_CONFIG);
      } catch (error) {
        console.error('ðŸ”´ Erro ao buscar conteÃºdo:', error);
        isInitialized = false; // Reset em caso de erro

        // ConfiguraÃ§Ã£o de fallback
        const fallbackConfig = {
          ...SCENARIO_CONFIG,
          successMessage:
            'ParabÃ©ns! VocÃª demonstrou compreender como diferentes intensidades de radiaÃ§Ã£o podem ser aplicadas em contextos especÃ­ficos, considerando tanto aspectos de seguranÃ§a quanto eficÃ¡cia terapÃªutica.',
          detailedExplanation:
            'A resposta correta considera que diferentes intensidades de radiaÃ§Ã£o sÃ£o mais apropriadas para diferentes tipos de aplicaÃ§Ãµes. AlÃ©m disso, a escolha do radioisÃ³topo deve levar em conta nÃ£o apenas a intensidade da radiaÃ§Ã£o, mas tambÃ©m o tipo de radiaÃ§Ã£o emitida, para garantir seguranÃ§a e eficÃ¡cia. A atenuaÃ§Ã£o da radiaÃ§Ã£o Ã© um aspecto fundamental que influencia diretamente na proteÃ§Ã£o e no desempenho da aplicaÃ§Ã£o. ' +
            'As outras respostas estÃ£o incorretas porque apresentam confusÃ£o sobre quais aplicaÃ§Ãµes sÃ£o adequadas para cada intensidade de radiaÃ§Ã£o, interpretam de forma errada os conceitos de atenuaÃ§Ã£o e blindagem, ou estabelecem associaÃ§Ãµes imprecisas entre os radioisÃ³topos e suas utilizaÃ§ÃµesNÃ£o cite o nÃºmero da alternativa como por exemplo primeira, segunda, terceria, quarta ou A, B, C, D ou 1, 2, 3, 4 pois as alternativas estÃ£o embaralhadas.',
        };

        // Atualiza a configuraÃ§Ã£o com fallback
        SCENARIO_CONFIG = fallbackConfig;
        updateConfig(SCENARIO_CONFIG);
      }
    };

    resetConfig();
    fetchScenarioContent();

    // Cleanup
    return () => {
      // NÃ£o reseta isInitialized no cleanup para manter o cache
    };
  }, [updateConfig]);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');

    const createParticle = () => {
      const angle = Math.random() * 2 * Math.PI;
      const speed = 2;
      return {
        x: SIMULATION_CONFIG.startPoint.x,
        y: SIMULATION_CONFIG.startPoint.y + (Math.random() - 0.5) * 20,
        vx: speed * Math.cos(angle),
        vy: speed * Math.sin(angle),
        active: true,
        trail: [{ x: SIMULATION_CONFIG.startPoint.x, y: SIMULATION_CONFIG.startPoint.y }],
        creationTime: Date.now(),
      };
    };

    const animate = () => {
      const currentTime = Date.now();
      const config = getSimulationConfig(scenarioNumber); // Atualizar aqui

      if (isPlaying) {
        if (
          currentTime - lastParticleTimeRef.current > config.particleInterval &&
          particlesRef.current.length < config.maxParticles
        ) {
          particlesRef.current.push(createParticle());
          lastParticleTimeRef.current = currentTime;
        }
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Desenhar fundo e label
      ctx.fillStyle = isDark ? '#e5e7eb' : '#1f2937';
      ctx.font = 'bold 20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`CenÃ¡rio ${scenarioNumber}`, canvas.width / 2, 30);

      // Barreira
      const gradient = ctx.createLinearGradient(
        SIMULATION_CONFIG.barrier.x,
        SIMULATION_CONFIG.barrier.y,
        SIMULATION_CONFIG.barrier.x + SIMULATION_CONFIG.barrier.width,
        SIMULATION_CONFIG.barrier.y
      );
      gradient.addColorStop(0, isDark ? '#4b5563' : '#6b7280');
      gradient.addColorStop(1, isDark ? '#374151' : '#9ca3af');
      ctx.fillStyle = gradient;
      ctx.fillRect(
        SIMULATION_CONFIG.barrier.x,
        SIMULATION_CONFIG.barrier.y,
        SIMULATION_CONFIG.barrier.width,
        SIMULATION_CONFIG.barrier.height
      );

      // Fonte
      ctx.beginPath();
      ctx.arc(SIMULATION_CONFIG.startPoint.x, SIMULATION_CONFIG.startPoint.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#ef4444';
      ctx.fill();

      // Atualiza e desenha partÃ­culas
      particlesRef.current = particlesRef.current.filter((particle) => {
        if (!particle.active) return false;

        if (isPlaying) {
          particle.x += particle.vx;
          particle.y += particle.vy;

          if (particle.x > canvas.width || particle.y < 0 || particle.y > canvas.height) {
            return false;
          }

          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 10) particle.trail.shift();

          if (
            particle.x >= SIMULATION_CONFIG.barrier.x &&
            particle.x <= SIMULATION_CONFIG.barrier.x + SIMULATION_CONFIG.barrier.width &&
            particle.y >= SIMULATION_CONFIG.barrier.y &&
            particle.y <= SIMULATION_CONFIG.barrier.y + SIMULATION_CONFIG.barrier.height
          ) {
            const rand = Math.random();
            if (rand < config.ricochetProbability) {
              particle.vx = -particle.vx;
              particle.x =
                particle.vx > 0
                  ? SIMULATION_CONFIG.barrier.x + SIMULATION_CONFIG.barrier.width + 1
                  : SIMULATION_CONFIG.barrier.x - 1;
            } else if (rand < config.ricochetProbability + config.transmissionProbability) {
              particle.x = SIMULATION_CONFIG.barrier.x + SIMULATION_CONFIG.barrier.width + 1;
              particle.trail = [{ x: particle.x, y: particle.y }];
            } else {
              return false;
            }
          }
        }

        // Desenha trilha
        ctx.beginPath();
        ctx.moveTo(particle.trail[0].x, particle.trail[0].y);
        particle.trail.forEach((point) => {
          ctx.lineTo(point.x, point.y);
        });
        ctx.strokeStyle = 'rgba(239, 68, 68, 0.3)';
        ctx.stroke();

        // Desenha partÃ­cula
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = '#ef4444';
        ctx.fill();

        return true;
      });

      animationFrameRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isPlaying, isDark, scenarioNumber]);

  return (
    <canvas
      ref={canvasRef}
      width={400}
      height={300}
      className={`border rounded-lg shadow-md ${isDark ? 'bg-gray-800' : 'bg-white'}`}
    />
  );
};

Scenario3.propTypes = {
  isPlaying: PropTypes.bool.isRequired,
  isDark: PropTypes.bool.isRequired,
  scenarioNumber: PropTypes.number,
};

// FunÃ§Ã£o para obter a configuraÃ§Ã£o do cenÃ¡rio
// FunÃ§Ã£o para obter a configuraÃ§Ã£o do cenÃ¡rio
export const getScenarioConfig = () => SCENARIO_CONFIG;

// Exporta a configuraÃ§Ã£o como constante
export { SCENARIO_CONFIG };

// Exporta o componente memoizado
export default React.memo(Scenario3);
